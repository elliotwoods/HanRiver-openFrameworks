#pragma once

//
//  projCamPair.h
//  testImgLoad
//
//  Created by Christopher Coleman-Smith on 2/3/12.
//  Copyright (c) 2012 Duke Uni. All rights reserved.
//
#include "ofxPFMImage.h"
#include "ofxRay.h"
#include <iostream>


#ifndef testImgLoad_projCamPair_h
#define testImgLoad_projCamPair_h


/**
 * class defines a projector camera pair, 
 * init with camera / projector locations / orientations
 * the correspondance pixels are stored in the pfmImage
 * 
 * a mesh of putative points is generated by intersecting rays from the 
 * camera / projector pixels 
 * this is stored as pointMesh
 *
 * \todo add methods to change the camera / projector view matrices
 * \todo add a color for the mesh?
 *
 * this should presumably be left open to calibration 
 */


class projCamPair{
public:
  projCamPair();
  projCamPair(const ofMatrix4x4& pProjView, int projW, int projH, 
              const ofMatrix4x4& cProjView, int cameraW, int cameraH, int projectorIndexIn);  
  void draw(); // draws the cam / proj and any points in the mesh we have
  
  void setPixels(ofFloatImage *pix);
  void setCubes(ofFloatImage *pix);
  
  
  /**
   * load pixel image from a bin file
   * just init pixels by passed in float image for now
   */
  //void loadPixels(string filename);
  
  /**
   * drop the points we find to a bin file
   */
  void dumpPoints(string filename);   
  
  /**
   * run through the points in the camera pixel image, read the index of each pixel
   * this is the corresponding projector pixel index (or a fuck up?)
   * create a ray from camera from this pixel and a ray from projector at its pixel
   * check that they intersect, if they do push the vertex into the point cloud
   * if they don't add the info to a failed list and go onto the next one
   */
  void procCorrespond();
  
  void processPixel(int pixelOwnIndex, int pixelValue);
  
  /**
   * we read the camera data, each correspondance pixel is
   * a pixel that we should turn on in the projector
   * their intersection defines our winning point
   */   
  ofProjector CaptureProjector;    
  ofProjector CaptureCamera; 
  int ncorrespond; // number of 'echos' that actually workedx
  ofFloatImage imgPixels; // raw pixels we process into a depth map  
  ofFloatImage xyzCubes; // the xyz locations (indexed by camera pixel)
  ofMesh pointMesh;

	/**
	 * which channel of imgPixels should we associate with 
	 * the projector
	 */
	int projectorIndex;
  
  ofRay projRayTest;
  ofRay camRayTest;
  ofRay interRay;
};


#endif
